import groovy.json.JsonSlurper
import org.gradle.initialization.DefaultSettings
import java.util.zip.ZipFile

def generatedFileName = "PackageList.java"
def generatedFilePackage = "co.median.android"
def generatedFileContentsTemplate = """
package $generatedFilePackage;

import android.app.Application;
import android.content.Context;
import android.content.res.Resources;

import co.median.median_core.BridgeModule;
import java.util.Arrays;
import java.util.ArrayList;

{{ packageImports }}

public class PackageList {
  private Application application;

  public PackageList(Application application) {
    this.application = application;
  }

  private Resources getResources() {
    return this.getApplication().getResources();
  }

  private Application getApplication() {
    return this.application;
  }

  private Context getApplicationContext() {
    return this.getApplication().getApplicationContext();
  }

  public ArrayList<BridgeModule> getPackages() {
    return new ArrayList<>(Arrays.<BridgeModule>asList(
      {{ packageClassInstances }}
    ));
  }
}
"""

class GoNativeModules {
    private Logger logger
    private ArrayList<HashMap<String, String>> localPluginsMetadata
    private ArrayList<HashMap<String, String>> compiledPluginsMetadata
    private ArrayList<HashMap<String, String>> allPluginsMetadata

    private packageName = "co.median.android"

    GoNativeModules(Logger logger) {
        this.logger = logger
        this.localPluginsMetadata = new ArrayList<HashMap<String, String>>()
        this.compiledPluginsMetadata = new ArrayList<HashMap<String, String>>()
        this.allPluginsMetadata = new ArrayList<HashMap<String, String>>()
    }

    void scanLocalPlugins() {
        this.localPluginsMetadata.clear()
        
        def finder = new FileNameFinder()
        def files = finder.getFileNames(System.getProperty("user.dir"), 'plugins/*/src/main/resources/META-INF/plugin-metadata.json')
        files.each { fileName ->
            def jsonFile = new File(fileName)
            if (jsonFile.exists()) {
                def parsedJson = new JsonSlurper().parseText(jsonFile.text).plugin
                // Extract plugin directory name from path: plugins/pluginName/src/main/resources/META-INF/plugin-metadata.json
                def pathParts = fileName.tokenize(File.separator)
                def pluginDirName = pathParts[pathParts.indexOf("plugins") + 1]
                parsedJson["sourceDir"] = "plugins/${pluginDirName}"
                parsedJson["isLocal"] = true
                this.localPluginsMetadata.push(parsedJson)
                this.logger.info("Found local plugin: ${parsedJson.pluginName} at ${parsedJson.sourceDir}")
            }
        }
    }

    void extractCompiledPlugins(Project project) {
        this.compiledPluginsMetadata.clear()
        
        try {
            def matchingArtifacts = project.configurations.medianPlugin.resolvedConfiguration.resolvedArtifacts.findAll { artifact ->
                artifact.moduleVersion.id.group == 'co.median.android.plugins'
            }

            matchingArtifacts.each {artifact ->
                if (artifact.type == 'aar') {
                    File aarFile = artifact.file

                    // Open the AAR file as a ZIP archive.
                    ZipFile aarZip = new ZipFile(aarFile)
                    def classesEntry = aarZip.getEntry("classes.jar")
                    if (classesEntry != null) {
                        // Get an InputStream for the embedded classes.jar.
                        InputStream classesStream = aarZip.getInputStream(classesEntry)

                        // Copy the stream to a temporary file so it can be opened as a ZipFile.
                        File tempClassesFile = File.createTempFile("tempClasses", ".jar")
                        tempClassesFile.deleteOnExit()
                        tempClassesFile.withOutputStream { out ->
                            out << classesStream
                        }

                        // Now open the temporary classes.jar as a ZIP.
                        ZipFile classesZip = new ZipFile(tempClassesFile)
                        def jsonEntry = classesZip.getEntry("META-INF/plugin-metadata.json")
                        if (jsonEntry != null) {
                            String jsonText = classesZip.getInputStream(jsonEntry).getText("UTF-8")
                            def parsedJson = new JsonSlurper().parseText(jsonText)
                            def pluginData = parsedJson["plugin"]
                            pluginData["isLocal"] = false
                            this.compiledPluginsMetadata.push(pluginData)
                            this.logger.info("Found compiled plugin: ${pluginData.pluginName}")
                        }
                        classesZip.close()
                    }
                    aarZip.close()
                }
            }
        } catch (Exception e) {
            this.logger.warn("No compiled plugins found or error extracting: ${e.message}")
        }
    }

    void mergePluginSources() {
        this.allPluginsMetadata.clear()
        
        // Start with local plugins (they take precedence)
        def localPluginNames = []
        this.localPluginsMetadata.each { plugin ->
            this.allPluginsMetadata.push(plugin)
            localPluginNames.push(plugin.pluginName)
        }
        
        // Add compiled plugins that don't have local equivalents
        this.compiledPluginsMetadata.each { plugin ->
            if (!localPluginNames.contains(plugin.pluginName)) {
                this.allPluginsMetadata.push(plugin)
            } else {
                this.logger.info("Skipping compiled plugin ${plugin.pluginName} - local version takes precedence")
            }
        }
        
        this.logger.info("Total plugins loaded: ${this.allPluginsMetadata.size()} (${this.localPluginsMetadata.size()} local, ${this.compiledPluginsMetadata.size() - localPluginNames.size()} compiled)")
    }

    void addModuleProjects(DefaultSettings defaultSettings) {
        // Only add local plugin projects to settings
        this.localPluginsMetadata.forEach { module ->
            String pluginName = module["pluginName"]
            String sourceDir = module["sourceDir"]
            this.logger.info("Including local plugin project: ${pluginName} from ${sourceDir}")
            defaultSettings.include(":${pluginName}")
            defaultSettings.project(":${pluginName}").projectDir = new File(defaultSettings.rootProject.projectDir, "./${sourceDir}")

            // Include local library required by the plugin
            String localLibrary = module["localLibrary"]
            if (localLibrary != null && !localLibrary.isEmpty()) {
                defaultSettings.include(":${localLibrary}")
                defaultSettings.project(":${localLibrary}").projectDir = new File(defaultSettings.rootProject.projectDir, "./${sourceDir}/${localLibrary}")
            }
        }
    }

    void addLocalModuleDependencies(Project appProject) {
        // Add only local plugin dependencies during configuration phase
        this.localPluginsMetadata.forEach { module ->
            String pluginName = module["pluginName"]
            this.logger.info("Adding local project dependency: ${pluginName}")
            appProject.dependencies {
                implementation project(path: ":${pluginName}")
            }
        }
    }

    void addModuleDependencies(Project appProject) {
        this.allPluginsMetadata.forEach { module ->
            String pluginName = module["pluginName"]
            boolean isLocal = module["isLocal"]
            
            if (isLocal) {
                // Add local project dependency
                this.logger.info("Adding local project dependency: ${pluginName}")
                appProject.dependencies {
                    implementation project(path: ":${pluginName}")
                }
            } else {
                // Compiled plugin dependency will be added via dependencies.json
                this.logger.info("Compiled plugin ${pluginName} will be loaded via AAR dependency")
            }
        }
    }
    
    void addPluginDependenciesFromJson(Project project) {
        File dependenciesFile = new File(project.rootDir, "dependencies.json")
        if (!dependenciesFile.exists()) {
            logger.warn("dependencies.json file not found at ${dependenciesFile.absolutePath}")
            return
        }
        
        try {
            def jsonSlurper = new JsonSlurper()
            def dependencies = jsonSlurper.parseText(dependenciesFile.text)
            def plugins = dependencies.remove("plugins")

            // Add plugins
            if (plugins) {
                project.dependencies {
                    plugins.each { key, value ->
                        implementation "co.median.android.plugins:${key}:${value}"
                        logger.info("Added plugin dependency: co.median.android.plugins:${key}:${value}")
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Failed to parse dependencies.json: ${e.message}")
        }
    }

    void generatePackagesFile(File outputDir, String generatedFileName, GString generatedFileContentsTemplate) {
        def packages = this.allPluginsMetadata
        String packageName = this.packageName

        String packageImports = ""
        String packageClassInstances = ""

        if (packages.size() > 0) {
            packageImports = "import ${packageName}.BuildConfig;\nimport ${packageName}.R;\n\n"
            packageImports = packageImports + packages.collect {
                "// ${it.name}\nimport ${it.packageName}.${it.classInstance};"
            }.join('\n')
            packageClassInstances = packages.collect { "new ${it.classInstance}()" }.join(",\n      ")
        }

        String generatedFileContents = generatedFileContentsTemplate.toString()
                .replace("{{ packageImports }}", packageImports)
                .replace("{{ packageClassInstances }}", packageClassInstances)

        outputDir.mkdirs()
        final FileTreeBuilder treeBuilder = new FileTreeBuilder(outputDir)
        treeBuilder.file(generatedFileName).newWriter().withWriter { w ->
            w << generatedFileContents
        }
    }
}

def gonativeModules = new GoNativeModules(logger)

ext.applyModulesSettingsGradle = { DefaultSettings defaultSettings ->
    // Scan for local plugins and add them to settings
    gonativeModules.scanLocalPlugins()
    gonativeModules.addModuleProjects(defaultSettings)
}

ext.applyNativeModulesAppBuildGradle = { Project project ->
    def generatedSrcDir = new File(buildDir, "generated/gncli/src/main/java")
    def generatedCodeDir = new File(generatedSrcDir, generatedFilePackage.replace('.', '/'))

    // Add plugin dependencies from dependencies.json (compiled plugins)
    gonativeModules.addPluginDependenciesFromJson(project)

    // Scan for local plugins early (before dependency resolution)
    gonativeModules.scanLocalPlugins()
    
    // Add local project dependencies immediately
    gonativeModules.addLocalModuleDependencies(project)

    tasks.register('generatePackageList') {
        doLast {
            // Scan for local plugins again (in case they changed)
            gonativeModules.scanLocalPlugins()
            
            // Extract compiled plugin metadata
            gonativeModules.extractCompiledPlugins(project)
            
            // Merge both sources (local takes precedence)
            gonativeModules.mergePluginSources()
            
            // Generate the unified PackageList.java
            gonativeModules.generatePackagesFile(generatedCodeDir, generatedFileName, generatedFileContentsTemplate)
        }
    }

    preBuild.dependsOn generatePackageList

    android {
        sourceSets {
            main {
                java {
                    srcDirs += generatedSrcDir
                }
            }
        }
        
        packagingOptions {
            exclude 'META-INF/plugin-metadata.json'
        }
    }
}
